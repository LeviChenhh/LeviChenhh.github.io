# Linux多进程

## 1. 进程的概念
 什么是进程？进程这个概念是针对系统而不是针对程序员的，对程序员来说，我们面对的概念是程序，当输入指令执行一个程序的时候，对系统而言，它将启动一个进程。

进程就是正在内存中运行中的程序，Linux下一个进程在内存里有三部分的数据，就是“代码段”、”堆栈段”和”数据段”。”代码段”，顾名思义，就是存放了程序代码。“堆栈段”存放的就是程序的返回地址、程序的参数以及程序的局部变量。而“数据段”则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用new函数分配的空间）。

系统如果同时运行多个相同的程序，它们的“代码段”是相同的，“堆栈段”和“数据段”是不同的（相同的程序，处理的数据不同）。

Linux的0\1\2号进程

idle进程：系统创建的第一个进程，加载系统
systemd(init)进程：系统初始化，是所有其他用户进程的祖先
kthreadd进程：负责所有内核线程的调度和管理。


每个进程都有一个非负整数表示的唯一进程ID

查看进程：``` ps -ef | grep 进程名```
多页显示```ps -ef |more```

获取进程ID：```pid_t getpid();```

获取父进程ID：```getppid(void)```

1）进程的ID是系统动态分配的，相同的程序在不同的时间执行，进程的编号是不同的。

2）进程的ID会循环使用，但是，在同一时间，进程的编号是唯一的，也就是说，不管任何时间，系统不可能存在两个编号相同的进程。

## 2. 多进程

```
pid_t fork();
```
一个现有的进程调用函数fork创建一个新的进程。新的进程叫子进程，原有的进程叫父进程，子进程和父进程继续执行fork函数后的代码。

fork函数调用一次，返回两次。
子进程返回0，父进程返回子进程的进程ID。
子进程是父进程的副本。
子进程获得了父进程的数据空间、堆和栈的副本，不是共享。
父进程中打开的文件描述符也被复制到子进程中（注意文件的缓冲区也会被复制，父进程中关闭文件，不影响子进程，反之同理）。
如果父进程先推出，子进程会成为孤儿进程。
如果子进程先退出，内核向父进程发送SIGVHID信号，如果父进程不处理这个信号，子进程会成为僵尸进程。


fork在英文中是“分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork函数，就产生了另一个进程，于是进程就“分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork函数

```
int main()
{
  printf("本程序的进程编号是：%d\n",getpid());
 
  int ipid=fork();
 
  sleep(1);       // sleep等待进程的生成。
 
  printf("pid=%d\n",ipid);
 
  if (ipid!=0) printf("父进程编号是：%d\n",getpid());
  else printf("子进程编号是：%d\n",getpid());
 
  sleep(30);    // 是为了方便查看进程在shell下用ps -ef|grep book252查看本进程的编号。
}

```

