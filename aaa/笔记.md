# 复合类型
& 取地址符
\* 解引用符
## 1. 指针
### 1.1. 指针的基本概念
变量的地址：内存变量简称变量，在C/C++语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。
指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号。
指针的声明、赋值、运算
```
/* 指针的声明 */
int iVar = 1024;

/* 指针的赋值 */
int *pVar = &iVar;

/* 指针的运算 */
*&*pVar;   //等同于*pi_1
int aVar[10] = {0};
int *ptmp = aVar;
aVar++;
aVar--;

/* 作为条件使用 */
if(pVar){}   //pi_1为0时，条件取false;任何非0指针对应的条件值都是true；

/* 指向指针的指针 */
int **pi;

```
注意点：
* 指针和引用都实现了对其他对象的间接访问；
* 指针本身就是一个对象，可以赋值和拷贝，可以在生命周期内先后指向几个不同的对象；
* 指针无需在定义时赋初值，但通常赋值NULL或nullptr，使用未初始化的指针是引发错误的一大原因;
* 指针直接赋值地址：只有特殊场景会使用；
* 所有指针的类型都要与它指向的对象严格匹配(编译时会警告：从不兼容的指针类型初始化)，两种情况除外；
* 一是允许令一个指向常量的指针指向一个非常量对象，但是不能通过指向常量的指针改变该非常量；
* 二是可以将基类的指针或引用指向派生类对象上；
* 指针的占用内存：任何类型的指针占用8字节的内存（32位操作系统4字节）;

### 1.2. 空指针和野指针
```
int *pi = 0;
int *pi1 = NULL;  //NULL预处理变量，值为0，<cstdlib>
int *pi2 = nullptr;   //nullptr是c++11引入的一种方法，可以被转换成任意其他的指针类型
```
没有赋值的指针变量（没有指向内存变量的地址），对空指针操作会造成程序的Core dump(段错误)

野指针：指针指向内存已释放，但指针的值不会被清零，对野指针操作的结果不可预知。规避方法：内存释放的时候将指针手动置为0；

### 1.3. void \*指针
void \*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\*指针存放着一个地址，但我们对该地址中存放的是什么类型的对象并不了解。利用void\* 指针能做的事比较有限：
* 不要将void \*与其他指针比较；
* 作为函数的输入或输出；
* 赋给另外一个void \*指针

### 1.4. 数组的地址

### 1.5. 指针和const
#### 1.5.1. 指向常量的指针
指向常量的指针不能用于改变其所指对象的值。想要存放常量对象的地址（间接访问常量对象），只能使用指向常量的指针。允许令一个指向常量的指针指向一个非常量对象，但是不能通过指向常量的指针改变该非常量。
```

```
指向常量的指针没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有对个对象的值不能通过其他途径改变。
#### 1.5.2. 常量指针
常量指针必须初始化，而且一旦初始化完成，则它的值（地址）就不能再改变了。
```
int i = 0;
int * const pi = &i;      //pi将一直指向i

const int j = 0;
int * const pj = &j;      //pj将一直指向常量i
```
### 1.6. 函数指针
c/c++每一个函数都有一个入口地址，函数指针是指向函数入口地址的指针变量。有了指向函数的指针变量后，可以用函数指针变量调用函数，就像用指针变量操作其他类型变量一样。
函数指针有两个用途：调用函数和做函数的参数。
```
#include <stdio.h>
int max(int x, int y)
{
    if(x > y) return x;
    return y;
}

int main()
{
    int a = 1, b = 2, c = 3;
    int (*ptr)(int, int);    //函数指针的声明, int后面加不加变量名都可以
    ptr = &max;
    //ptr = max; 一样    

    c = (*ptr)(a, b);
    //c = ptr(a, b);也可以
    printf("a = %d, b = %d, max = %d\n", a, b, c);
    return 0;
}

```
应用举例，回调函数：
```
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
sort(begin, end, cmp); //cmp是函数指针
```

应用举例，类的多态。

指针函数：返回值为地址的函数就是指针函数。


### 1.7. 多级指针
指针也是内存变量，只要是内存变量，就会有地址，多级指针即指针的指针，指针的指针的指针。。。。但没有应用场景。

### 1.8. 指针的应用场景
函数的参数
scanf， memset
* 在函数中需要改变变量的值；
* 减少内存的开销；

函数的返回值
malloc
fopen

## 2. 引用
### 2.1. 引用的基本概念
引用就是变量的别名，对引用的操作与对变量直接操作完全一样。
引用的声明：
```
int ii = 1024;
int &ri_1 = ii;
int &ri_2;   //报错，引用必须初始化

/* 指向指针的引用 */
int *p = nullptr;
int *&rReferceToPoint = p;    //声明从右向左读，最近的符号对变量的类型有直接的影响

int iVar = 10;
rReferceToPoint = &iVar;    //将iVar的地址赋给p
*rReferceToPoint = 0;       //将iVar的值赋为0
```
注意点：
* 引用必须初始化；
* 引用一旦绑定，则无法重新绑定到另一个对象；
* 引用并非对象，没有实际地址，**不能定义指向引用的指针**；
* 不能定义引用的引用；
* 对引用的操作就是对绑定的对象的操作；
* 引用只能绑定在对象上，不能与某个字面值或某个表达式的计算结果绑定在一起；
* 引用的类型必须与其所引用对象的类型一致，但是有两个例外；
* 一是初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
* 二是可以将基类的指针或引用绑定到派生类对象上

### 2.2. const与引用
将引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（简称常量引用，因为引用只能与一个对象绑定，所以没有常量的引用一说），对常量的引用不能被用作修改它所绑定的对象。
```
const int ci = 1024;
const int &r1 = ci;    //正确，引用及其对应的的对象都是常量

r1 = 42;               //错误，r1是对常量的引用
int &r2 = ci;          //错误，试图让一个非常量引用指向一个常量引用
```

初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2;
double dval = 3.14;
const int &ri = dval;   //绑定了一个由double生成的int临时量


int &r4 = r1 * 2;      //错误: r4是一个普通的非常量引用
```

常量引用不需要引用的对象是const：常量引用仅对引用可参与的操作做了限定，对于引用的对象本身是不是一个常量未作限定。
```
int i = 42;
int &r1 = i;
const int &r2 = i;
r1 = 0;
r2 = 0;         //错误：让r2是一个常量引用
```


## 3. 附录
### 3.1. 顶层const
指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。
顶层const：表示指针本身是一个常量。
底层const：所指的对象是一个常量。

更一般的，顶层const可以表示任意对象是常量，对任何数据类型都适用。
底层const则与指针和引用等复合类型的基本类型部分有关。

比较特别的是，指针既可以是顶层const也可以是底层const。

```
int i = 0;
int *const p1 =  &i;    //顶层const
const int ci = 42;      //顶层const
const int *p2 = &i;     //底层const
const int *const p3 = p2;    //右侧顶层const, 左侧底层const
```

执行对象的拷贝操作时：
```
i = ci;     //顶层const无影响
p2 = p3;    //顶层const无影响

//而底层const却不能忽视，底层const的属性只能添加，不能去除。
int *p = p3;     //错误
p2 = p3；        //正确
p2 = &i;         //正确，添加const
int &r = ci;     //错误
const int &r2 = i;   //正确
```

